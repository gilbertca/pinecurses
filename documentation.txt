Pinecurses Documentation
Author: Christopher Gilbert

Pinecurses - py ncurses

================================================================================
INTRODUCTION:
================================================================================
Creating pretty, easy-to-use, feature-packed interfaces can be a challenge.

The python wrapper for the ncurses library contains all of the tools required to create wonderful tools.

However, the curses library for python only wraps the ncurses library, and ncurses is somewhat arcane.

Once one is familiar with the curses library, it is quite simple to create an application with curses.

However, modularity must be implemented by the user; otherwise each application interfaces uniquely with curses.

Each application tends to be single-purpose, and using curses effectively relies more on personal convention than any agreed upon standard.

================================================================================
PURPOSE:
================================================================================
The Pinecurses library attempts to provide these key benefits:

	1. Reusability - Creating modular componenets which can be used elsewhere.

	2. Simplification - Removing unnecessary boilerplate, and automating processes (such as screen positioning).

================================================================================
REUSABILITY:
================================================================================
The Pinecurses library aims to allow the creation of reusable applications.

The ideal application which uses Pinecurses is completely unaware of Pinecurses.

Pinecurses is to act as the 'front end' of a program, making calls to a hypothetical 'back end' which provides the data to be displayed.

So, a properly created Pinecurses program would theoretically allow for hot-swapping backends, and multiple applications can have similar displays by using the same Pinecurses front end so long as their display requirements are similar.

Likewise, depending on a client's needs, a single application could have multiple front ends, such as a GTK GUI and a Pinecurses TUI.

================================================================================
SIMPLIFICATION:
================================================================================
The Pinecurses library aims to simplify the creation of TUI front ends.

Using the Pinecurses library encourages *bigger picture thinking*.

Rather than focusing on *how* to display an element to the screen, the programmer would focus on *where* they want to display an element and *what* the element should look like, and the Pinecurses library should handle the *how*.

The Pinecurses library does this by offering a myriad of keyword attributes which can be set to define how an element is displayed without the need to run these calculations ad hoc.

An example set of these attributes may appear something like:
attributes = {
	text_color = red,
	background_color = black,
	height = 90%,
	width = 10,
	alignment = left-center
}
These attributes would produce an element with:
* Red text 
* Black background
* Relative height of 90% of available height
* Absolute width of 10 cells
* Content aligned to the left horizontally
* Content aligned the the center vertically

A programmer attempting to position content to this degree would likely face two scenarios:

	1. Programming each of these features would be hardcoded, and changing a feature would require editing that feature's code.

	2. The programmer would have to implement their own modular display manager to allow centralized editing of these features.

In the second case, the programmer would effectively have to create their own version of Pinecurses.

Rather than repeating ourselves over and over, we can make using curses more DRY, and encourage TUI development.

================================================================================
STRUCTURE:
================================================================================
The structure of a Pinecurses program can be thought of as a tree. Like, the real kind... outside.

There are four primary components to any Pinecurses TUI:

	1. Trunks (formerly Controllers)

	2. Branches (formerly Views)

	3. Leaves (formerly Items)
	
	4. Roots

Just like a real tree, a Pinecurses Program follows a similar structure:
Leaf	Leaf	Leaf	Leaf
  \	 /	  \	 /
   Branch	   Branch
	  \	 /
	   Trunk
	     |
	   Roots

Leaves can be thought of as the final display element. Some examples of leaves include:
	
	* An entry in a list or menu
	* A text box for user input or program output, such as an area for sending or receiving a message
	* Message text or button contained within a popup menu

Branches can be thought of as a collection of display elements. Branches can have many leaves, but a single leaf can not be connected to multiple branches. Examples of Branches include:

	* A list or menu containing multiple entries
	* A collection of text boxes, such as a chat client with separate areas for sent and received messages
	* A popup menu which may contain text or buttons

Trunks can be thought of as the glue for a Pinecurses interface. A trunk can have multiple branches, but a branch can not be connected to multiple Trunks.

The Trunk of a Pinecurses TUI performs several important functions, and they typically will not have any display elements associated with them.

The Trunk is responsible for allowing the various branches to communicate with each other, as well as providing programwide functionality.

For example: Pressing the Enter key may result in different effects based on what the user has selected within the interface; while pressing the Escape key may cause the application to quit regardless of the screen's state. In this example, the Trunk is responsible for detecting the Escape key, and properly handling exit conditions.

In theory, if a programmer were to create multiple trunks for different interfaces, they could both operate at the same time, provided another higher-level Trunk is created with the same One-to-Many relationship.

[ROOTS ARE THEORETICAL AT THIS POINT IN TIME]

Roots are what connects the Tree to everything else. A Trunk can only have one set of Roots, and Roots can only connect to one Trunk.

Roots are the API for a Pinecurses TUI. If anything goes on outside of the Pinecurses loop, the interface can be informed of this activity via the Roots, and the Trunk can delegate any required updates to the Branches and Leaves.

================================================================================
INTERFACES:
================================================================================
Simplicity is one of the key ideas behind a Pinecurses.

In order to maintain this simplicity, Pinecurses offers relatively few (albeit detailed) interfaces.

The interfaces which most programmers are as follows:

	1. Keyword attributes - json, or other markup
	2. Key mapping - key presses to function calls
	3. 

================================================================================
SIMPLEST USE CASES:
================================================================================
The potential requirements of any interface are limitless.

In order to maintain the simplicity behind the Pinecurses library, Pinecurses should primarily be used for specific use cases.

Although a savvy programmer may be able to modify Pinecurses to suit a particular niche, there may be other libraries better suited for those cases.

With that in mind, Pinecurses and it's features will be primarily focused on a few *simple* use cases.

These use cases are:

	* Menus/Lists with selectable entries
	* Prettified/Formatted text and/or outputs from commands
	*

Again, anything is possible, and Pinecurses can be extended to include features which cater to use cases not mentioned above.

However, the further one strays from these use cases, the more effort and time will be put into those features.
